# Day 4: Content Collections - Part 1 (Fundamentals)

**Duration:** 60 minutes  
**Level:** Intermediate  
**Prerequisites:** Basic Astro knowledge, TypeScript fundamentals

---

## üéØ Learning Objectives

By the end of this lesson, you will be able to:
- Create and configure content collections with type-safe schemas
- Query collection entries using Astro's Content API
- Implement Zod validation for frontmatter data
- Build dynamic pages from collection entries
- Sort and filter content efficiently

---

## üìö Theory Part (20 minutes)

### What are Content Collections?

Content Collections are Astro's way of organizing and managing content with **built-in type safety**. They transform your Markdown, MDX, JSON, and YAML files into queryable, validated data structures.

**Key Benefits:**
- ‚úÖ **Type Safety**: Compile-time validation with TypeScript
- ‚úÖ **Auto-completion**: IntelliSense support in your IDE
- ‚úÖ **Schema Validation**: Frontmatter validation using Zod
- ‚úÖ **Better Organization**: Structured content in `src/content/`
- ‚úÖ **Performance**: Optimized content queries at build time

### Collection Structure

Content collections live in the `src/content/` directory with the following structure:

```
project-root/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ content/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ blog/              # üìù Blog collection
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ post-1.md
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ post-2.md
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ post-3.md
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ docs/              # üìö Documentation collection
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ intro.md
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ guide.md
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ config.ts          # üîß Schema definitions
‚îÇ   ‚îî‚îÄ‚îÄ pages/
‚îî‚îÄ‚îÄ astro.config.mjs
```

### Schema Definition with Zod

Zod is a TypeScript-first schema validation library that Astro uses for content validation.

**Basic Schema Example:**

```typescript
import { defineCollection, z } from 'astro:content';
import { glob } from 'astro/loaders';

const blog = defineCollection({
  // üîç Loader: Specifies how to load content
  loader: glob({ pattern: '**/*.md', base: './src/content/blog' }),
  
  // ‚úÖ Schema: Defines and validates frontmatter structure
  schema: z.object({
    title: z.string(),                           // Required string
    description: z.string(),                     // Required string
    publishDate: z.date(),                       // Required date
    author: z.string(),                          // Required string
    tags: z.array(z.string()),                   // Required array of strings
    draft: z.boolean().default(false),           // Optional boolean with default
    image: z.string().optional(),                // Optional string
  }),
});

// üì§ Export collections object
export const collections = { blog };
```

### Content Loaders

Astro provides two main loaders:

**1. `glob()` Loader** - For multiple files with patterns:
```typescript
import { glob } from 'astro/loaders';

loader: glob({ 
  pattern: '**/*.md',              // üéØ Match all .md files
  base: './src/content/blog'       // üìÅ Base directory
})
```

**2. `file()` Loader** - For single files:
```typescript
import { file } from 'astro/loaders';

loader: file('./src/data/config.json')
```

### TypeScript Benefits

With content collections, you get:

```typescript
// ‚úÖ Autocomplete for entry properties
const post = await getEntry('blog', 'my-post');
post.data.title    // TypeScript knows this exists!
post.data.author   // Autocomplete works!

// ‚ùå TypeScript error if schema doesn't match
post.data.nonExistent  // Error: Property doesn't exist
```

---

## üíª Practice Part (35 minutes)

### Exercise 1: Create a Blog Collection (20 minutes)

#### Step 1: Create the Configuration File

Create `src/content/config.ts`:

```typescript
// üì¶ Import required utilities from Astro
import { defineCollection, z } from 'astro:content';
import { glob } from 'astro/loaders';

// üìù Define the blog collection with schema
const blog = defineCollection({
  // üîç Load all markdown files from blog directory
  loader: glob({ 
    pattern: '**/*.md', 
    base: './src/content/blog' 
  }),
  
  // ‚úÖ Define the schema for blog posts
  schema: z.object({
    title: z.string(),                    // üìå Post title (required)
    description: z.string(),              // üìÑ Post description (required)
    publishDate: z.coerce.date(),         // üìÖ Publication date (auto-converts strings)
    author: z.string(),                   // ‚úçÔ∏è Post author (required)
    image: z.string().optional(),         // üñºÔ∏è Optional cover image URL
    tags: z.array(z.string()),            // üè∑Ô∏è Array of tags
    draft: z.boolean().default(false),    // üìù Draft status (defaults to false)
  }),
});

// üì§ Export collections for Astro to use
export const collections = { blog };
```

#### Step 2: Create Blog Posts

Create `src/content/blog/first-post.md`:

```markdown
---
title: "Welcome to My Blog"
description: "This is my very first blog post where I introduce myself and my journey."
publishDate: 2024-01-15
author: "Jane Developer"
image: "/images/welcome.jpg"
tags: ["introduction", "personal"]
draft: false
---

# Welcome! üëã

This is my first blog post. I'm excited to start sharing my thoughts and experiences!

## What to Expect

In this blog, I'll be writing about:
- Web development
- Technology trends
- My learning journey

Stay tuned for more content!
```

Create `src/content/blog/astro-islands.md`:

```markdown
---
title: "Understanding Astro Islands Architecture"
description: "A deep dive into how Astro's islands architecture enables partial hydration for better performance."
publishDate: 2024-01-20
author: "Jane Developer"
tags: ["astro", "architecture", "performance"]
draft: false
---

# Astro Islands üèùÔ∏è

Astro's Islands Architecture is a revolutionary approach to building web applications...

## Key Concepts

1. **Partial Hydration**: Only interactive components load JavaScript
2. **Island Isolation**: Each island loads independently
3. **Performance First**: Minimal JavaScript by default

This architecture leads to faster page loads and better user experience!
```

Create `src/content/blog/web-performance.md`:

```markdown
---
title: "Web Performance Optimization Tips"
description: "Essential techniques to make your website blazing fast in 2024."
publishDate: 2024-01-25
author: "Jane Developer"
image: "/images/performance.jpg"
tags: ["performance", "optimization", "best-practices"]
draft: false
---

# Web Performance Matters üöÄ

In today's fast-paced web, performance is not optional‚Äîit's essential.

## Top Optimization Techniques

1. **Image Optimization**: Use modern formats like WebP
2. **Code Splitting**: Load only what you need
3. **Caching Strategies**: Leverage browser and CDN caching
4. **Lazy Loading**: Defer non-critical resources

Implementing these techniques can dramatically improve your site's performance!
```

### Exercise 2: Create a Blog Listing Page (15 minutes)

Create `src/pages/blog/index.astro`:

```astro
---
// üì¶ Import required utilities
import { getCollection } from 'astro:content';
import Layout from '../../layouts/BaseLayout.astro';

// üîç Fetch all blog posts from the collection
const posts = await getCollection('blog');

// üìä Sort posts by publication date (newest first)
const sortedPosts = posts.sort((a, b) => 
  b.data.publishDate.getTime() - a.data.publishDate.getTime()
);

// üéØ Filter out draft posts in production
const publishedPosts = import.meta.env.PROD 
  ? sortedPosts.filter(post => !post.data.draft)
  : sortedPosts;
---

<Layout title="Blog">
  <div class="blog-container">
    <h1>Blog Posts üìù</h1>
    <p class="subtitle">
      Discover {publishedPosts.length} articles about web development and technology
    </p>
    
    <ul class="posts-list">
      {publishedPosts.map(post => (
        <li class="post-card">
          <a href={`/blog/${post.id}`}>
            {/* üñºÔ∏è Display image if available */}
            {post.data.image && (
              <img 
                src={post.data.image} 
                alt={post.data.title}
                class="post-image"
              />
            )}
            
            <div class="post-content">
              <h2>{post.data.title}</h2>
              <p class="description">{post.data.description}</p>
              
              <div class="post-meta">
                {/* üìÖ Format publication date */}
                <time datetime={post.data.publishDate.toISOString()}>
                  {post.data.publishDate.toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric'
                  })}
                </time>
                
                {/* ‚úçÔ∏è Display author */}
                <span class="author">by {post.data.author}</span>
              </div>
              
              {/* üè∑Ô∏è Display tags */}
              <div class="tags">
                {post.data.tags.map(tag => (
                  <span class="tag">#{tag}</span>
                ))}
              </div>
            </div>
          </a>
        </li>
      ))}
    </ul>
  </div>
</Layout>

<style>
  .blog-container {
    max-width: 800px;
    margin: 0 auto;
    padding: 2rem;
  }

  h1 {
    font-size: 2.5rem;
    margin-bottom: 0.5rem;
    color: #333;
  }

  .subtitle {
    color: #666;
    margin-bottom: 2rem;
  }

  .posts-list {
    list-style: none;
    padding: 0;
    display: flex;
    flex-direction: column;
    gap: 2rem;
  }

  .post-card {
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    overflow: hidden;
    transition: transform 0.2s, box-shadow 0.2s;
  }

  .post-card:hover {
    transform: translateY(-4px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  }

  .post-card a {
    text-decoration: none;
    color: inherit;
    display: block;
  }

  .post-image {
    width: 100%;
    height: 200px;
    object-fit: cover;
  }

  .post-content {
    padding: 1.5rem;
  }

  .post-content h2 {
    margin: 0 0 0.5rem 0;
    color: #2563eb;
  }

  .description {
    color: #666;
    margin-bottom: 1rem;
    line-height: 1.6;
  }

  .post-meta {
    display: flex;
    gap: 1rem;
    font-size: 0.9rem;
    color: #888;
    margin-bottom: 1rem;
  }

  .tags {
    display: flex;
    gap: 0.5rem;
    flex-wrap: wrap;
  }

  .tag {
    background-color: #e0e7ff;
    color: #3730a3;
    padding: 0.25rem 0.75rem;
    border-radius: 12px;
    font-size: 0.85rem;
  }
</style>
```

---

## üéì Quick Review - Key Concepts (10 minutes)

### 1. Type Safety with Zod

```typescript
// ‚úÖ Zod provides compile-time validation
schema: z.object({
  title: z.string(),              // Must be a string
  count: z.number(),              // Must be a number
  isPublished: z.boolean(),       // Must be a boolean
  tags: z.array(z.string()),      // Must be array of strings
})
```

**Benefits:**
- Catches errors before runtime
- Provides autocomplete in IDE
- Documents your data structure

### 2. Querying Collections

```typescript
// üìö Get all entries from a collection
const allPosts = await getCollection('blog');

// üîç Filter entries using a callback
const publishedPosts = await getCollection('blog', ({ data }) => {
  return data.draft !== true;
});

// üìñ Get a single entry by ID
const specificPost = await getEntry('blog', 'my-post');
```

### 3. Common Zod Patterns

```typescript
z.string()                          // Required string
z.string().optional()               // Optional string
z.string().default('Default')       // String with default value
z.number().min(0).max(100)          // Number with constraints
z.boolean().default(false)          // Boolean with default
z.array(z.string())                 // Array of strings
z.date()                            // Date object
z.coerce.date()                     // Auto-convert to date
z.enum(['draft', 'published'])      // Limited options
```

### 4. Content Organization Best Practices

```
‚úÖ DO:
- Keep related content in the same collection
- Use descriptive file names
- Define comprehensive schemas
- Use TypeScript for config files

‚ùå DON'T:
- Mix unrelated content types
- Skip schema validation
- Use inconsistent frontmatter
- Forget to export collections
```

---

## ‚úÖ Checklist - What You Should Know After Day 4

After completing this lesson, you should be able to:

- [x] **Create content collections** with schema definitions in `src/content/config.ts`
- [x] **Define type-safe schemas** using Zod with various data types
- [x] **Query collections** using `getCollection()` and `getEntry()`
- [x] **Sort and filter** collection entries based on data properties
- [x] **Understand the directory structure** for `src/content/` organization
- [x] **Access frontmatter data** using `entry.data.propertyName`
- [x] **Generate dynamic routes** from collection entries
- [x] **Validate content** automatically with Zod schemas

---

## üöÄ Next Steps

**For Tomorrow's Lesson (Day 5):**
- Dynamic routing with collection entries
- Rendering individual blog posts
- Working with MDX components
- Advanced filtering techniques

**Practice Exercises:**
1. Add a "portfolio" collection with projects
2. Create a tags page that lists all unique tags
3. Implement a search feature for blog posts
4. Add image validation using Zod's `image()` helper

---

## üìñ Additional Resources

- [Astro Content Collections Documentation](https://docs.astro.build/en/guides/content-collections/)
- [Zod Documentation](https://zod.dev/)
- [TypeScript Handbook](https://www.typescriptlang.org/docs/)

---

## üí° Common Troubleshooting

**Problem:** TypeScript errors about missing types
**Solution:** Run `npm run astro sync` to regenerate types

**Problem:** Collection not found
**Solution:** Check that `collections` is exported in `config.ts`

**Problem:** Date parsing errors
**Solution:** Use `z.coerce.date()` instead of `z.date()` for string dates

**Problem:** Schema validation failing
**Solution:** Ensure frontmatter matches schema exactly, check for typos

---