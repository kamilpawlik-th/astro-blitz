# Day 3: Islands Architecture & Client Directives

## Course Goal
Master Astro's Islands Architecture for partial hydration and understand when and how to add interactivity to your static sites.

---

## Part 1: Theory (20 minutes)

### 1.1 Understanding Islands Architecture

**What is Islands Architecture?**

Islands Architecture is a revolutionary approach to web development that treats your page as a sea of static HTML with interactive "islands" of functionality. Think of it as having a mostly static beach with a few interactive tide pools.

**Key Principles:**
- **Static HTML as the Foundation**: By default, everything is static HTML/CSS with zero JavaScript
- **Interactive "Islands"**: Only specific components that need interactivity get JavaScript
- **Independent Hydration**: Each island loads and becomes interactive independently
- **Minimal JavaScript Payload**: Dramatically reduced bundle sizes (often 90%+ reduction)

**Traditional vs Islands Architecture:**

```
Traditional SPA:
[========================================]
         All JavaScript (Heavy)

Islands Architecture:
[‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë]
Static HTML    Interactive Islands
```

### 1.2 Client Directives - Your Hydration Control Panel

Astro provides five client directives that control **when** and **how** components become interactive:

#### `client:load`
- **When it hydrates**: Immediately on page load
- **Priority**: High
- **Use for**: Critical interactive UI elements
- **Example use cases**: 
  - Navigation menus
  - Search bars
  - Authentication forms
  - Shopping cart buttons

```astro
<SearchBar client:load />
```

#### `client:idle`
- **When it hydrates**: After the page finishes loading and browser is idle
- **Priority**: Medium
- **Use for**: Non-critical UI elements
- **Example use cases**:
  - Chat widgets
  - Newsletter signup forms
  - Analytics components
  - Social media feeds

```astro
<ChatWidget client:idle />
```

#### `client:visible`
- **When it hydrates**: When component enters the viewport
- **Priority**: On-demand
- **Use for**: Below-the-fold content
- **Example use cases**:
  - Image galleries
  - Comment sections
  - Video players
  - Infinite scroll content

```astro
<ImageCarousel client:visible />
```

#### `client:media`
- **When it hydrates**: Based on CSS media query match
- **Priority**: Conditional
- **Use for**: Responsive components
- **Example use cases**:
  - Mobile-only hamburger menus
  - Desktop-only sidebars
  - Device-specific features

```astro
<MobileMenu client:media="(max-width: 768px)" />
```

#### `client:only`
- **When it hydrates**: Immediately, skips server rendering
- **Priority**: Client-only
- **Use for**: Client-dependent components
- **Example use cases**:
  - Canvas/WebGL visualizations
  - Browser API-dependent components
  - Components using `window` or `document`

```astro
<WebGLVisualization client:only="react" />
```

### 1.3 When to Use Each Directive - Decision Tree

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Does the component need to be       ‚îÇ
‚îÇ interactive immediately?            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚îú‚îÄ YES ‚îÄ‚îÄ‚Üí client:load
         ‚îÇ
         ‚îî‚îÄ NO
            ‚îÇ
            ‚îú‚îÄ Is it visible on first load?
            ‚îÇ
            ‚îÇ   ‚îú‚îÄ NO ‚îÄ‚îÄ‚Üí client:visible
            ‚îÇ   ‚îÇ
            ‚îÇ   ‚îî‚îÄ YES
            ‚îÇ       ‚îÇ
            ‚îÇ       ‚îú‚îÄ Is it critical for UX?
            ‚îÇ       ‚îÇ
            ‚îÇ       ‚îÇ   ‚îú‚îÄ NO ‚îÄ‚îÄ‚Üí client:idle
            ‚îÇ       ‚îÇ   ‚îÇ
            ‚îÇ       ‚îÇ   ‚îî‚îÄ YES ‚îÄ‚îÄ‚Üí client:load
            ‚îÇ
            ‚îî‚îÄ Device-specific? ‚îÄ‚îÄ‚Üí client:media
            
            ‚îî‚îÄ Uses browser APIs only? ‚îÄ‚îÄ‚Üí client:only
```

### 1.4 Framework Integration

Astro supports multiple UI frameworks in a single project:

- **React**
- **Vue**
- **Svelte**
- **Solid**
- **Preact**
- **Lit**

**Best Practices:**
- Use `.astro` files for static content and layouts
- Use framework components only when you need interactivity
- Mix frameworks if needed (e.g., React for complex UI, Svelte for simple widgets)
- Keep the majority of your site static

---

## Part 2: Practice (35 minutes)

### Exercise 1: Build an Interactive Counter with Different Hydration Strategies (15 min)

#### Step 1: Install React

```bash
npx astro add react
```

#### Step 2: Create the Counter Component

Create `src/components/Counter.tsx`:

```tsx
import { useState } from 'react';

// Define props interface for type safety
interface CounterProps {
  initialCount?: number;
  label?: string;
}

export default function Counter({ initialCount = 0, label = "Count" }: CounterProps) {
  // State to track the current count value
  const [count, setCount] = useState(initialCount);
  
  // Track when component hydrated for demonstration
  const [hydrationTime] = useState(() => new Date().toISOString());
  
  return (
    <div style={{
      padding: '1.5rem',
      border: '2px solid #4F46E5',
      borderRadius: '8px',
      margin: '1rem 0',
      backgroundColor: '#F9FAFB'
    }}>
      <h3 style={{ marginTop: 0 }}>{label}</h3>
      
      {/* Display current count */}
      <p style={{ fontSize: '2rem', fontWeight: 'bold', color: '#4F46E5' }}>
        {count}
      </p>
      
      {/* Control buttons */}
      <div style={{ display: 'flex', gap: '0.5rem', marginBottom: '1rem' }}>
        <button 
          onClick={() => setCount(count + 1)}
          style={{
            padding: '0.5rem 1rem',
            backgroundColor: '#4F46E5',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            cursor: 'pointer'
          }}
        >
          Increment ‚ûï
        </button>
        
        <button 
          onClick={() => setCount(count - 1)}
          style={{
            padding: '0.5rem 1rem',
            backgroundColor: '#DC2626',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            cursor: 'pointer'
          }}
        >
          Decrement ‚ûñ
        </button>
        
        <button 
          onClick={() => setCount(0)}
          style={{
            padding: '0.5rem 1rem',
            backgroundColor: '#6B7280',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            cursor: 'pointer'
          }}
        >
          Reset üîÑ
        </button>
      </div>
      
      {/* Show hydration timestamp for learning purposes */}
      <p style={{ fontSize: '0.75rem', color: '#6B7280' }}>
        Hydrated at: {new Date(hydrationTime).toLocaleTimeString()}
      </p>
    </div>
  );
}
```

#### Step 3: Create a Demo Page

Create `src/pages/counter-demo.astro`:

```astro
---
import Counter from '../components/Counter';

// This is server-side code that runs at build time
const pageTitle = "Counter Hydration Demo";
---

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>{pageTitle}</title>
  <style>
    body {
      font-family: system-ui, -apple-system, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 2rem;
      background: linear-gradient(to bottom, #EEF2FF, #FFFFFF);
    }
    .section {
      margin: 2rem 0;
      padding: 1.5rem;
      background: white;
      border-radius: 12px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    .note {
      background: #FEF3C7;
      padding: 1rem;
      border-left: 4px solid #F59E0B;
      margin: 1rem 0;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <h1>üèùÔ∏è {pageTitle}</h1>
  
  <div class="note">
    <strong>üìù Instructions:</strong> Open your browser's DevTools Network tab to see 
    when JavaScript loads for each counter. Notice the difference in timing!
  </div>

  <!-- client:load - Hydrates immediately on page load -->
  <div class="section">
    <h2>1Ô∏è‚É£ client:load - Immediate Hydration</h2>
    <p>
      <strong>When it loads:</strong> Immediately when the page loads<br>
      <strong>Use for:</strong> Critical interactive elements (navigation, search, forms)
    </p>
    <Counter client:load initialCount={0} label="Immediate Counter" />
  </div>

  <!-- client:idle - Hydrates when browser is idle -->
  <div class="section">
    <h2>2Ô∏è‚É£ client:idle - Idle Hydration</h2>
    <p>
      <strong>When it loads:</strong> After page load completes and browser is idle<br>
      <strong>Use for:</strong> Non-critical UI (chat widgets, analytics)
    </p>
    <Counter client:idle initialCount={10} label="Idle Counter" />
  </div>

  <!-- client:visible - Hydrates when entering viewport -->
  <div class="section">
    <h2>3Ô∏è‚É£ client:visible - Lazy Hydration</h2>
    <p>
      <strong>When it loads:</strong> When the component becomes visible in viewport<br>
      <strong>Use for:</strong> Below-the-fold content (galleries, comments)
    </p>
    <Counter client:visible initialCount={20} label="Visible Counter" />
  </div>

  <!-- Add some spacer content to push next counter below the fold -->
  <div style="height: 400px; background: linear-gradient(to bottom, #E0E7FF, #C7D2FE); 
              margin: 2rem 0; border-radius: 12px; display: flex; align-items: center; 
              justify-content: center; font-size: 1.5rem;">
    üëá Scroll down to see the next counter hydrate! üëá
  </div>

  <!-- Another client:visible example below the fold -->
  <div class="section">
    <h2>4Ô∏è‚É£ client:visible - Below the Fold</h2>
    <p>
      This counter only loads JavaScript when you scroll it into view!
    </p>
    <Counter client:visible initialCount={30} label="Lazy-Loaded Counter" />
  </div>

  <!-- client:media - Conditional hydration based on screen size -->
  <div class="section">
    <h2>5Ô∏è‚É£ client:media - Responsive Hydration</h2>
    <p>
      <strong>When it loads:</strong> Only when screen matches media query<br>
      <strong>Use for:</strong> Device-specific components
    </p>
    
    <!-- Only hydrates on mobile screens -->
    <Counter 
      client:media="(max-width: 768px)" 
      initialCount={40} 
      label="Mobile-Only Counter (< 768px)" 
    />
    
    <!-- Only hydrates on desktop screens -->
    <Counter 
      client:media="(min-width: 769px)" 
      initialCount={50} 
      label="Desktop-Only Counter (> 768px)" 
    />
  </div>

  <!-- No directive - Static HTML only -->
  <div class="section">
    <h2>6Ô∏è‚É£ No Directive - Static HTML</h2>
    <p>
      <strong>When it loads:</strong> Never! This is static HTML only<br>
      <strong>Result:</strong> Buttons won't work, but page loads instantly
    </p>
    <Counter initialCount={99} label="Static Counter (No JavaScript!)" />
  </div>

  <div class="note">
    <strong>üí° Key Takeaway:</strong> Use the right directive for the right job. 
    Most of your page should be static HTML. Only add JavaScript where you need interactivity!
  </div>
</body>
</html>
```

#### Step 4: Test and Observe

1. Start your dev server: `npm run dev`
2. Open `http://localhost:4321/counter-demo`
3. Open Browser DevTools > Network tab
4. Filter for JavaScript files
5. Notice when each counter's JavaScript loads
6. Try resizing the browser window for `client:media` examples

---

### Exercise 2: Build a Visibility-Based Image Gallery (20 min)

#### Step 1: Create an Interactive Image Card Component

Create `src/components/ImageCard.tsx`:

```tsx
import { useState } from 'react';

interface ImageCardProps {
  src: string;
  alt: string;
  title: string;
  description: string;
}

export default function ImageCard({ src, alt, title, description }: ImageCardProps) {
  // Track if image has been viewed
  const [isViewed, setIsViewed] = useState(false);
  // Track loading state
  const [isLoading, setIsLoading] = useState(true);
  // Track if image is expanded
  const [isExpanded, setIsExpanded] = useState(false);

  // Handle image load completion
  const handleImageLoad = () => {
    setIsLoading(false);
    setIsViewed(true);
  };

  return (
    <div style={{
      border: '2px solid #E5E7EB',
      borderRadius: '8px',
      overflow: 'hidden',
      transition: 'transform 0.2s, box-shadow 0.2s',
      cursor: 'pointer',
      backgroundColor: 'white',
      transform: isExpanded ? 'scale(1.05)' : 'scale(1)',
      boxShadow: isExpanded ? '0 10px 25px rgba(0,0,0,0.2)' : '0 1px 3px rgba(0,0,0,0.1)',
      position: 'relative'
    }}
    onClick={() => setIsExpanded(!isExpanded)}
    >
      {/* Loading skeleton */}
      {isLoading && (
        <div style={{
          width: '100%',
          height: '200px',
          background: 'linear-gradient(90deg, #F3F4F6 25%, #E5E7EB 50%, #F3F4F6 75%)',
          animation: 'shimmer 2s infinite',
        }} />
      )}
      
      {/* Actual image */}
      <img
        src={src}
        alt={alt}
        onLoad={handleImageLoad}
        style={{
          width: '100%',
          height: '200px',
          objectFit: 'cover',
          display: isLoading ? 'none' : 'block'
        }}
      />
      
      {/* Content overlay */}
      <div style={{ padding: '1rem' }}>
        <h3 style={{ margin: '0 0 0.5rem 0', color: '#1F2937' }}>
          {title}
        </h3>
        <p style={{ margin: 0, color: '#6B7280', fontSize: '0.875rem' }}>
          {description}
        </p>
        
        {/* Status indicator */}
        <div style={{
          marginTop: '0.5rem',
          fontSize: '0.75rem',
          color: isViewed ? '#10B981' : '#6B7280'
        }}>
          {isViewed ? '‚úÖ Loaded & Interactive' : '‚è≥ Loading...'}
        </div>
        
        {/* Click hint */}
        <div style={{
          marginTop: '0.5rem',
          fontSize: '0.75rem',
          color: '#9CA3AF',
          fontStyle: 'italic'
        }}>
          {isExpanded ? 'üîΩ Click to collapse' : 'üîº Click to expand'}
        </div>
      </div>
    </div>
  );
}
```

#### Step 2: Create the Gallery Page

Create `src/pages/gallery.astro`:

```astro
---
import ImageCard from '../components/ImageCard';

// Sample image data - using placeholder service
const images = [
  {
    id: 1,
    src: 'https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=400',
    alt: 'Mountain landscape',
    title: 'Mountain Peak',
    description: 'Majestic mountain views at sunrise'
  },
  {
    id: 2,
    src: 'https://images.unsplash.com/photo-1469474968028-56623f02e42e?w=400',
    alt: 'Forest path',
    title: 'Forest Trail',
    description: 'Peaceful walk through the woods'
  },
  {
    id: 3,
    src: 'https://images.unsplash.com/photo-1441974231531-c6227db76b6e?w=400',
    alt: 'River valley',
    title: 'River Valley',
    description: 'Flowing waters through green valleys'
  },
  {
    id: 4,
    src: 'https://images.unsplash.com/photo-1426604966848-d7adac402bff?w=400',
    alt: 'Desert dunes',
    title: 'Desert Dunes',
    description: 'Golden sands under blue skies'
  },
  {
    id: 5,
    src: 'https://images.unsplash.com/photo-1472214103451-9374bd1c798e?w=400',
    alt: 'Ocean waves',
    title: 'Ocean Waves',
    description: 'Crashing waves on rocky shores'
  },
  {
    id: 6,
    src: 'https://images.unsplash.com/photo-1465146344425-f00d5f5c8f07?w=400',
    alt: 'Autumn forest',
    title: 'Autumn Colors',
    description: 'Fall foliage in full display'
  },
  {
    id: 7,
    src: 'https://images.unsplash.com/photo-1470071459604-3b5ec3a7fe05?w=400',
    alt: 'Snowy peaks',
    title: 'Snow Mountains',
    description: 'Winter wonderland peaks'
  },
  {
    id: 8,
    src: 'https://images.unsplash.com/photo-1475924156734-496f6cac6ec1?w=400',
    alt: 'Sunset sky',
    title: 'Sunset Vista',
    description: 'Colorful evening skies'
  },
  {
    id: 9,
    src: 'https://images.unsplash.com/photo-1447752875215-b2761acb3c5d?w=400',
    alt: 'Flower field',
    title: 'Flower Meadow',
    description: 'Blooming wildflowers'
  },
  {
    id: 10,
    src: 'https://images.unsplash.com/photo-1501594907352-04cda38ebc29?w=400',
    alt: 'Lake view',
    title: 'Crystal Lake',
    description: 'Tranquil lake reflections'
  },
  {
    id: 11,
    src: 'https://images.unsplash.com/photo-1433086966358-54859d0ed716?w=400',
    alt: 'Waterfall',
    title: 'Cascading Falls',
    description: 'Powerful waterfall descent'
  },
  {
    id: 12,
    src: 'https://images.unsplash.com/photo-1470252649378-9c29740c9fa8?w=400',
    alt: 'Canyon view',
    title: 'Grand Canyon',
    description: 'Vast canyon landscapes'
  }
];
---

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Image Gallery - client:visible Demo</title>
  <style>
    body {
      font-family: system-ui, -apple-system, sans-serif;
      margin: 0;
      padding: 2rem;
      background: linear-gradient(to bottom, #F3F4F6, #FFFFFF);
      min-height: 100vh;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
    }
    
    h1 {
      text-align: center;
      color: #1F2937;
      margin-bottom: 0.5rem;
    }
    
    .subtitle {
      text-align: center;
      color: #6B7280;
      margin-bottom: 2rem;
    }
    
    .info-box {
      background: #DBEAFE;
      border-left: 4px solid #3B82F6;
      padding: 1rem;
      margin-bottom: 2rem;
      border-radius: 4px;
    }
    
    .info-box h3 {
      margin-top: 0;
      color: #1E40AF;
    }
    
    .info-box ul {
      margin-bottom: 0;
      color: #1E3A8A;
    }
    
    /* Grid layout for gallery */
    .gallery {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 1.5rem;
      margin-bottom: 3rem;
    }
    
    .stats {
      position: sticky;
      top: 1rem;
      background: white;
      padding: 1rem;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-bottom: 2rem;
      z-index: 10;
    }
    
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
    }
    
    .stat-item {
      text-align: center;
      padding: 0.5rem;
    }
    
    .stat-value {
      font-size: 2rem;
      font-weight: bold;
      color: #3B82F6;
    }
    
    .stat-label {
      font-size: 0.875rem;
      color: #6B7280;
    }

    /* Shimmer animation for loading state */
    @keyframes shimmer {
      0% { background-position: -400px 0; }
      100% { background-position: 400px 0; }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üñºÔ∏è Lazy-Loading Image Gallery</h1>
    <p class="subtitle">Powered by client:visible directive</p>
    
    <div class="info-box">
      <h3>üìö What you're seeing:</h3>
      <ul>
        <li><strong>Each image card is an island</strong> - Only becomes interactive when visible</li>
        <li><strong>JavaScript loads on-demand</strong> - Check Network tab to see lazy loading in action</li>
        <li><strong>Significant performance boost</strong> - Images below fold don't block initial page load</li>
        <li><strong>Try scrolling slowly</strong> - Watch the status indicators change as cards hydrate</li>
      </ul>
    </div>

    <div class="stats">
      <div class="stats-grid">
        <div class="stat-item">
          <div class="stat-value">{images.length}</div>
          <div class="stat-label">Total Images</div>
        </div>
        <div class="stat-item">
          <div class="stat-value">~90%</div>
          <div class="stat-label">JS Reduction</div>
        </div>
        <div class="stat-item">
          <div class="stat-value">‚ö°</div>
          <div class="stat-label">Instant Load</div>
        </div>
      </div>
    </div>

    <!-- 
      The gallery grid - each ImageCard uses client:visible
      This means JavaScript only loads when the card enters viewport
    -->
    <div class="gallery">
      {images.map((image) => (
        <ImageCard
          client:visible
          src={image.src}
          alt={image.alt}
          title={image.title}
          description={image.description}
        />
      ))}
    </div>

    <div class="info-box" style="background: #D1FAE5; border-left-color: #10B981;">
      <h3>‚úÖ Performance Benefits</h3>
      <p><strong>Without client:visible:</strong> All 12 components load JavaScript immediately (heavy initial load)</p>
      <p><strong>With client:visible:</strong> Only visible components load JavaScript (fast initial load, smooth progressive enhancement)</p>
      <p>Open DevTools ‚Üí Network tab ‚Üí Filter by JS to see the difference!</p>
    </div>
  </div>

  <script>
    // Add a simple scroll progress indicator
    window.addEventListener('scroll', () => {
      const winScroll = document.body.scrollTop || document.documentElement.scrollTop;
      const height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
      const scrolled = (winScroll / height) * 100;
      
      // You could add a progress bar here if desired
      console.log(`Page scrolled: ${scrolled.toFixed(0)}%`);
    });
  </script>
</body>
</html>
```

#### Step 3: Compare Performance

1. Open `http://localhost:4321/gallery`
2. Open DevTools ‚Üí Network tab
3. Notice: Only ~3-4 components load initially (those visible in viewport)
4. Scroll down slowly
5. Watch new JavaScript bundles load as images become visible
6. Check the "Status" indicators on each card

**Try this experiment:**
1. Comment out `client:visible` from all `<ImageCard>` components
2. Refresh the page
3. See all 12 components load JavaScript immediately
4. Notice the difference in initial load time!

---

## Part 3: Quick Review - Key Concepts (10 minutes)

### Core Principles

#### 1. Partial Hydration
- **Concept**: Only send JavaScript for interactive components
- **Benefit**: 90%+ reduction in JavaScript payload
- **Default**: Components are static HTML unless you add a `client:*` directive

#### 2. Strategic Loading
- **Right directive for the right job**
- **Priority cascade**: `client:load` > `client:idle` > `client:visible`
- **Consider**: Time to interactive vs. importance

#### 3. Framework Flexibility
- **Mix frameworks freely**: React header + Svelte widgets + Vue forms
- **No framework lock-in**: Choose the best tool for each job
- **Static by default**: Use `.astro` files for non-interactive content

#### 4. Performance by Default
- **No directive = No JavaScript**
- **Pay-as-you-go**: Only ship what you use
- **Islands remain isolated**: One broken island doesn't break the entire page

### Quick Reference Table

| Directive | When Hydrates | Priority | Use Case | Example |
|-----------|---------------|----------|----------|---------|
| `client:load` | Page load | High | Critical UI | Navigation, Search |
| `client:idle` | Browser idle | Medium | Non-critical UI | Chat, Analytics |
| `client:visible` | Enters viewport | On-demand | Below-fold | Galleries, Comments |
| `client:media` | Media query match | Conditional | Responsive | Mobile menus |
| `client:only` | Page load (no SSR) | Client-only | Browser APIs | Canvas, WebGL |
| (none) | Never | N/A | Static content | Text, Images |

### Common Patterns

```astro
---
import Header from '../components/Header.astro'; // Static
import SearchBar from '../components/SearchBar.tsx'; // Interactive
import ChatWidget from '../components/ChatWidget.tsx'; // Interactive
import ImageGallery from '../components/ImageGallery.tsx'; // Interactive
---

<!-- Static header - no JavaScript needed -->
<Header />

<!-- Critical search - load immediately -->
<SearchBar client:load />

<!-- Non-critical chat - load when idle -->
<ChatWidget client:idle />

<!-- Below-fold gallery - load when visible -->
<ImageGallery client:visible />
```

---

## Checklist - What You Should Know After Day 3

### Understanding ‚úÖ

- [ ] **Islands Architecture Concept**
  - Explain the difference between traditional SPA and Islands Architecture
  - Understand why static HTML is the foundation
  - Recognize when to add interactivity vs. keeping content static

### Technical Skills ‚úÖ

- [ ] **Client Directives Mastery**
  - Know when to use each of the 5 client directives
  - Understand the performance implications of each directive
  - Can explain the hydration timeline for different directives

- [ ] **Framework Integration**
  - Can add React (or other framework) to an Astro project
  - Can create interactive components in your chosen framework
  - Understand how to pass props from Astro to framework components

### Practical Application ‚úÖ

- [ ] **Performance Optimization**
  - Can identify components that don't need JavaScript
  - Know how to measure JavaScript bundle sizes
  - Can use browser DevTools to verify lazy loading

- [ ] **Code Implementation**
  - Successfully created a working Counter component
  - Built a lazy-loaded image gallery
  - Tested different hydration strategies

### Best Practices ‚úÖ

- [ ] **Decision Making**
  - Can choose the appropriate directive for new components
  - Understand the trade-offs between immediate and lazy loading
  - Know when to avoid JavaScript entirely

---

## Additional Resources

### Official Documentation
- [Astro Islands](https://docs.astro.build/en/concepts/islands/)
- [Client Directives Reference](https://docs.astro.build/en/reference/directives-reference/)
- [Framework Components Guide](https://docs.astro.build/en/guides/framework-components/)

### Going Further
- Experiment with mixing multiple frameworks (React + Svelte + Vue)
- Build a dashboard with different hydration strategies
- Create a blog with interactive comment sections using `client:visible`
- Implement a mobile-responsive navigation with `client:media`

### Performance Tips
- Use `client:visible` for anything below the fold
- Reserve `client:load` for truly critical interactions
- Most components should have no directive at all
- Monitor bundle sizes with `astro build` and analyze the output

---

## Homework Challenge üöÄ

**Build a "Performance Comparison Dashboard"**

Create a page with three sections:
1. **Immediate Section** - Counter with `client:load`
2. **Lazy Section** - Image gallery with `client:visible`
3. **Conditional Section** - Mobile menu with `client:media`

Add a performance monitor that tracks:
- Total JavaScript loaded
- Time to first interaction
- Number of hydrated components

**Bonus**: Add a toggle to switch between "all client:load" and "optimized directives" to see the performance difference!
