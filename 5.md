# Day 5: Content Collections - Part 2 (Advanced Features)

**Duration:** 60 minutes  
**Level:** Intermediate  
**Prerequisites:** Understanding of Astro basics and Content Collections fundamentals

---

## ðŸŽ¯ Learning Objectives

By the end of this session, you will be able to:
- Create dynamic routes using `getStaticPaths()` with content collections
- Render Markdown/MDX content as components using the `render()` function
- Implement type-safe references between collections
- Work with both content and data collections
- Understand SSG vs SSR strategies for content collections

---

## ðŸ“š Part 1: Theory (20 minutes)

### 1.1 Dynamic Routes with getStaticPaths (5 min)

Dynamic routes allow you to generate multiple pages from a single template file. In Astro, this is accomplished using the `getStaticPaths()` function.

**How it works:**

```typescript
// src/pages/blog/[slug].astro
export async function getStaticPaths() {
  // Fetch all blog posts from the collection
  const posts = await getCollection('blog');
  
  // Map each post to a unique route
  return posts.map(post => ({
    params: { slug: post.id },  // Defines the URL parameter
    props: { post },            // Passes data to the component
  }));
}
```

**Key Points:**
- `params` object must match the dynamic segment in your filename (e.g., `[slug].astro`)
- `props` object passes data to your component template
- The function runs at build time for Static Site Generation (SSG)
- Each post generates a unique URL (e.g., `/blog/my-first-post`)

### 1.2 Rendering Content (5 min)

The `render()` function compiles your Markdown or MDX content into a renderable component.

```typescript
import { render } from 'astro:content';

// Get the post from props
const { post } = Astro.props;

// Render the post content
const { Content } = await render(post);
```

**What render() returns:**

```typescript
{
  Content: Component,           // The rendered content component
  headings: Array<{             // Extracted headings for TOC
    depth: number,
    slug: string,
    text: string
  }>,
  remarkPluginFrontmatter: any  // Modified frontmatter from plugins
}
```

**Usage in template:**

```astro
---
const { Content } = await render(post);
---
<article>
  <h1>{post.data.title}</h1>
  <Content />  <!-- Renders the actual content -->
</article>
```

### 1.3 Collection References (5 min)

References allow you to create relationships between different collections, similar to foreign keys in databases.

**Defining References:**

```typescript
import { defineCollection, z, reference } from 'astro:content';

const authors = defineCollection({
  type: 'data',
  schema: z.object({
    name: z.string(),
    bio: z.string(),
    avatar: z.string(),
    twitter: z.string().optional(),
  }),
});

const blog = defineCollection({
  type: 'content',
  schema: z.object({
    title: z.string(),
    description: z.string(),
    publishDate: z.date(),
    // Single reference to authors collection
    author: reference('authors'),
    // Array of references to blog posts
    relatedPosts: z.array(reference('blog')),
    tags: z.array(z.string()),
  }),
});

export const collections = { blog, authors };
```

**Benefits:**
- Type safety: TypeScript knows the shape of referenced data
- Autocomplete: Your editor suggests valid collection names
- Validation: Ensures referenced entries exist at build time
- Clean data modeling: Separate concerns into logical collections

### 1.4 SSG vs SSR Considerations (5 min)

**Static Site Generation (SSG):**

```typescript
// Runs at BUILD TIME
export async function getStaticPaths() {
  const posts = await getCollection('blog');
  return posts.map(post => ({
    params: { slug: post.id },
    props: { post },
  }));
}
```

- All pages generated at build time
- Fast page loads (HTML is pre-rendered)
- Best for content that doesn't change frequently
- Default mode in Astro

**Server-Side Rendering (SSR):**

```typescript
// Runs at REQUEST TIME
export const prerender = false; // Disable prerendering

const { slug } = Astro.params;

// Fetch entry on-demand
const post = await getEntry('blog', slug);

if (!post) {
  return Astro.redirect('/404');
}

const { Content } = await render(post);
```

- Pages generated on each request
- Dynamic content possible
- Requires an SSR adapter
- Slightly slower initial page load

**Hybrid Approach:**

You can mix both strategies in the same project:

```typescript
// Most pages: SSG (default)
// Specific pages: SSR (opt-in)
export const prerender = false;
```

---

## ðŸ’» Part 2: Practice (35 minutes)

### Exercise 1: Create Dynamic Blog Post Pages (15 min)

**Step 1:** Create the dynamic route file

```astro
---
// src/pages/blog/[slug].astro
import { getCollection, render } from 'astro:content';
import Layout from '../../layouts/BaseLayout.astro';

/**
 * Generate static paths for all blog posts
 * This function runs at build time
 */
export async function getStaticPaths() {
  // Fetch all blog posts from the content collection
  const posts = await getCollection('blog');
  
  // Map each post to a route with parameters and props
  return posts.map(post => ({
    params: { slug: post.id },  // URL parameter
    props: { post },             // Data passed to component
  }));
}

// Extract post from props
const { post } = Astro.props;

// Render the Markdown/MDX content
const { Content } = await render(post);

// Format the publish date
const formattedDate = post.data.publishDate.toLocaleDateString('en-US', {
  year: 'numeric',
  month: 'long',
  day: 'numeric'
});
---

<Layout title={post.data.title}>
  <article class="blog-post">
    <!-- Post header -->
    <header>
      <h1>{post.data.title}</h1>
      
      <!-- Metadata section -->
      <div class="meta">
        <time datetime={post.data.publishDate.toISOString()}>
          {formattedDate}
        </time>
        <span class="author">By {post.data.author}</span>
      </div>
      
      <!-- Description -->
      {post.data.description && (
        <p class="description">{post.data.description}</p>
      )}
    </header>
    
    <!-- Rendered content from Markdown/MDX -->
    <div class="content">
      <Content />
    </div>
    
    <!-- Post footer with tags -->
    <footer>
      <div class="tags">
        {post.data.tags.map(tag => (
          <a href={`/tags/${tag}`} class="tag">
            #{tag}
          </a>
        ))}
      </div>
    </footer>
  </article>
</Layout>

<style>
  .blog-post {
    max-width: 65ch;
    margin: 0 auto;
    padding: 2rem 1rem;
  }

  header {
    margin-bottom: 2rem;
    border-bottom: 2px solid #e5e7eb;
    padding-bottom: 2rem;
  }

  h1 {
    font-size: 2.5rem;
    font-weight: 700;
    margin-bottom: 1rem;
    line-height: 1.2;
  }

  .meta {
    display: flex;
    gap: 1rem;
    color: #6b7280;
    font-size: 0.875rem;
  }

  .description {
    margin-top: 1rem;
    font-size: 1.125rem;
    color: #4b5563;
  }

  .content {
    margin-bottom: 3rem;
    line-height: 1.7;
  }

  .tags {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
  }

  .tag {
    padding: 0.25rem 0.75rem;
    background: #f3f4f6;
    border-radius: 0.375rem;
    text-decoration: none;
    color: #374151;
    font-size: 0.875rem;
    transition: background 0.2s;
  }

  .tag:hover {
    background: #e5e7eb;
  }
</style>
```

**Step 2:** Create a blog post example

```markdown
---
# src/content/blog/getting-started.md
title: "Getting Started with Astro"
description: "Learn the basics of building with Astro"
publishDate: 2024-01-15
author: "Sarah Johnson"
tags: ["astro", "web-development", "tutorial"]
---

# Welcome to Astro!

Astro is a modern web framework for building **fast, content-focused websites**.

## Why Choose Astro?

- ðŸš€ **Fast by default**: Zero JavaScript runtime
- ðŸŽ¨ **Component-based**: Use your favorite UI framework
- ðŸ“¦ **Content Collections**: Type-safe content management

## Getting Started

Start building amazing websites today!
```

### Exercise 2: Add Authors Collection with References (20 min)

**Step 1:** Update the content config

```typescript
// src/content/config.ts
import { defineCollection, z, reference } from 'astro:content';
import { glob } from 'astro/loaders';

/**
 * Authors collection - stores author data
 * Type: 'data' (JSON/YAML files)
 */
const authors = defineCollection({
  type: 'data',
  schema: z.object({
    name: z.string(),
    bio: z.string(),
    avatar: z.string(),           // Path to avatar image
    twitter: z.string().optional(), // Optional Twitter handle
    website: z.string().url().optional(),
  }),
});

/**
 * Blog collection - stores blog posts
 * Type: 'content' (Markdown/MDX files)
 */
const blog = defineCollection({
  type: 'content',
  schema: z.object({
    title: z.string(),
    description: z.string(),
    publishDate: z.date(),
    
    // Reference to a single author from the authors collection
    // This provides type safety and validation
    author: reference('authors'),
    
    // Optional: Array of related posts
    relatedPosts: z.array(reference('blog')).optional(),
    
    tags: z.array(z.string()),
    
    // Optional fields
    draft: z.boolean().default(false),
    image: z.object({
      url: z.string(),
      alt: z.string(),
    }).optional(),
  }),
});

// Export collections for Astro to recognize
export const collections = { blog, authors };
```

**Step 2:** Create author data files

```json
// src/content/authors/sarah-johnson.json
{
  "name": "Sarah Johnson",
  "bio": "Full-stack developer and technical writer passionate about web performance and developer experience.",
  "avatar": "/images/avatars/sarah.jpg",
  "twitter": "@sarahj_dev",
  "website": "https://sarahjohnson.dev"
}
```

```json
// src/content/authors/michael-chen.json
{
  "name": "Michael Chen",
  "bio": "Frontend architect specializing in modern web frameworks and component design systems.",
  "avatar": "/images/avatars/michael.jpg",
  "twitter": "@mchen_tech"
}
```

**Step 3:** Update blog posts to reference authors

```markdown
---
# src/content/blog/getting-started.md
title: "Getting Started with Astro"
description: "Learn the basics of building with Astro"
publishDate: 2024-01-15
author: "sarah-johnson"  # Reference to authors collection by ID
tags: ["astro", "web-development", "tutorial"]
---

Content goes here...
```

**Step 4:** Update the blog post page to display author info

```astro
---
// src/pages/blog/[slug].astro
import { getCollection, getEntry, render } from 'astro:content';
import Layout from '../../layouts/BaseLayout.astro';

export async function getStaticPaths() {
  const posts = await getCollection('blog');
  return posts.map(post => ({
    params: { slug: post.id },
    props: { post },
  }));
}

const { post } = Astro.props;
const { Content } = await render(post);

/**
 * Resolve the author reference
 * getEntry fetches the full author data from the authors collection
 */
const author = await getEntry(post.data.author);

// Resolve related posts if they exist
const relatedPosts = post.data.relatedPosts 
  ? await getEntries(post.data.relatedPosts)
  : [];
---

<Layout title={post.data.title}>
  <article class="blog-post">
    <header>
      <h1>{post.data.title}</h1>
      
      <!-- Author card with resolved reference data -->
      <div class="author-card">
        <img 
          src={author.data.avatar} 
          alt={author.data.name}
          class="avatar"
        />
        <div class="author-info">
          <div class="author-name">{author.data.name}</div>
          <div class="author-bio">{author.data.bio}</div>
          
          <!-- Social links -->
          <div class="author-links">
            {author.data.twitter && (
              <a 
                href={`https://twitter.com/${author.data.twitter.replace('@', '')}`}
                target="_blank"
                rel="noopener noreferrer"
              >
                Twitter
              </a>
            )}
            {author.data.website && (
              <a 
                href={author.data.website}
                target="_blank"
                rel="noopener noreferrer"
              >
                Website
              </a>
            )}
          </div>
        </div>
      </div>
      
      <time datetime={post.data.publishDate.toISOString()}>
        {post.data.publishDate.toLocaleDateString('en-US', {
          year: 'numeric',
          month: 'long',
          day: 'numeric'
        })}
      </time>
    </header>
    
    <!-- Post content -->
    <div class="content">
      <Content />
    </div>
    
    <!-- Related posts section -->
    {relatedPosts.length > 0 && (
      <aside class="related-posts">
        <h2>Related Articles</h2>
        <ul>
          {relatedPosts.map(related => (
            <li>
              <a href={`/blog/${related.id}`}>
                {related.data.title}
              </a>
              <p>{related.data.description}</p>
            </li>
          ))}
        </ul>
      </aside>
    )}
    
    <!-- Tags -->
    <footer>
      <div class="tags">
        {post.data.tags.map(tag => (
          <a href={`/tags/${tag}`} class="tag">
            #{tag}
          </a>
        ))}
      </div>
    </footer>
  </article>
</Layout>

<style>
  .author-card {
    display: flex;
    gap: 1rem;
    padding: 1.5rem;
    background: #f9fafb;
    border-radius: 0.5rem;
    margin: 1.5rem 0;
  }

  .avatar {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    object-fit: cover;
  }

  .author-info {
    flex: 1;
  }

  .author-name {
    font-weight: 600;
    font-size: 1.125rem;
    margin-bottom: 0.25rem;
  }

  .author-bio {
    color: #6b7280;
    font-size: 0.875rem;
    margin-bottom: 0.5rem;
  }

  .author-links {
    display: flex;
    gap: 1rem;
  }

  .author-links a {
    font-size: 0.875rem;
    color: #3b82f6;
    text-decoration: none;
  }

  .author-links a:hover {
    text-decoration: underline;
  }

  .related-posts {
    margin-top: 3rem;
    padding: 1.5rem;
    background: #f9fafb;
    border-radius: 0.5rem;
  }

  .related-posts h2 {
    margin-top: 0;
  }

  .related-posts ul {
    list-style: none;
    padding: 0;
  }

  .related-posts li {
    margin-bottom: 1rem;
  }

  .related-posts a {
    font-weight: 600;
    color: #1f2937;
    text-decoration: none;
  }

  .related-posts a:hover {
    color: #3b82f6;
  }
</style>
```

**Step 5:** Create a blog index page

```astro
---
// src/pages/blog/index.astro
import { getCollection } from 'astro:content';
import Layout from '../../layouts/BaseLayout.astro';

/**
 * Fetch all blog posts and filter out drafts
 * Sort by publish date (newest first)
 */
const posts = (await getCollection('blog'))
  .filter(post => !post.data.draft)
  .sort((a, b) => 
    b.data.publishDate.getTime() - a.data.publishDate.getTime()
  );
---

<Layout title="Blog">
  <div class="blog-index">
    <h1>Blog</h1>
    
    <div class="posts-grid">
      {posts.map(post => (
        <article class="post-card">
          <a href={`/blog/${post.id}`}>
            <h2>{post.data.title}</h2>
            <p class="description">{post.data.description}</p>
            
            <div class="meta">
              <time datetime={post.data.publishDate.toISOString()}>
                {post.data.publishDate.toLocaleDateString('en-US', {
                  year: 'numeric',
                  month: 'short',
                  day: 'numeric'
                })}
              </time>
              
              <div class="tags">
                {post.data.tags.slice(0, 3).map(tag => (
                  <span class="tag">#{tag}</span>
                ))}
              </div>
            </div>
          </a>
        </article>
      ))}
    </div>
  </div>
</Layout>

<style>
  .blog-index {
    max-width: 1200px;
    margin: 0 auto;
    padding: 2rem 1rem;
  }

  h1 {
    font-size: 3rem;
    margin-bottom: 3rem;
  }

  .posts-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 2rem;
  }

  .post-card {
    padding: 1.5rem;
    border: 1px solid #e5e7eb;
    border-radius: 0.5rem;
    transition: all 0.2s;
  }

  .post-card:hover {
    box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1);
    transform: translateY(-2px);
  }

  .post-card a {
    text-decoration: none;
    color: inherit;
  }

  .post-card h2 {
    margin-top: 0;
    margin-bottom: 0.5rem;
    font-size: 1.5rem;
  }

  .description {
    color: #6b7280;
    margin-bottom: 1rem;
  }

  .meta {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 0.875rem;
  }

  time {
    color: #6b7280;
  }

  .tags {
    display: flex;
    gap: 0.5rem;
  }

  .tag {
    color: #6b7280;
  }
</style>
```

---

## ðŸŽ“ Quick Review - Key Concepts (5 minutes)

### 1. Dynamic Routes
```typescript
export async function getStaticPaths() {
  const posts = await getCollection('blog');
  return posts.map(post => ({
    params: { slug: post.id },
    props: { post },
  }));
}
```
- Use `getStaticPaths()` to generate pages from collections
- `params` defines URL structure
- `props` passes data to component

### 2. Content Rendering
```typescript
const { Content } = await render(post);
```
- `render()` converts Markdown/MDX to React-like components
- Returns `Content` component, `headings`, and `remarkPluginFrontmatter`
- Use `<Content />` in template to display

### 3. References
```typescript
author: reference('authors')
```
- Link related content across collections with type safety
- Use `getEntry()` for single references
- Use `getEntries()` for array references
- Validates at build time

### 4. Flexible Data
- **Content collections**: Markdown/MDX files with frontmatter
- **Data collections**: JSON/YAML files
- Both support schemas and validation
- Perfect for blogs, documentation, and structured data

### 5. SSG vs SSR
- **SSG (default)**: Use `getStaticPaths()` for build-time generation
- **SSR**: Set `prerender = false` for request-time rendering
- **Hybrid**: Mix both strategies in same project
- Choose based on content update frequency

---

## âœ… Checklist - What You Should Know

After completing Day 5, you should be able to:

- âœ… **Create dynamic routes** from collection entries using `getStaticPaths()`
- âœ… **Render Markdown/MDX content** as components with `render()`
- âœ… **Implement references** between collections using `reference()`
- âœ… **Work with both** content collections (Markdown/MDX) and data collections (JSON/YAML)
- âœ… **Query specific entries** with `getEntry()` and `getEntries()`
- âœ… **Understand the difference** between SSG and SSR rendering strategies
- âœ… **Build type-safe** content-driven applications

---

## ðŸš€ Next Steps

Now that you've mastered advanced content collections, consider:

1. **Add pagination** to your blog index using Astro's `paginate()` function
2. **Create tag pages** to organize content by topics
3. **Implement full-text search** using tools like Pagefind
4. **Add RSS feeds** for blog subscribers
5. **Explore MDX** for interactive content with components

---

## ðŸ“š Additional Resources

- [Astro Content Collections Documentation](https://docs.astro.build/en/guides/content-collections/)
- [Astro Routing Guide](https://docs.astro.build/en/guides/routing/)
- [Zod Documentation](https://zod.dev/) - Schema validation library
- [Community Examples](https://astro.build/themes/) - Explore real-world implementations

---
