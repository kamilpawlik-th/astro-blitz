# Day 5: Astro Performance Optimization & Partial Hydration

## Goal
Master Astro's performance optimization techniques, understand the Islands Architecture, implement partial hydration strategies, and leverage View Transitions for smooth navigation.

---

## Theory Part (20 min)

### 1. Understanding Astro's Islands Architecture

**What are Astro Islands?**
- Astro Islands represent interactive UI components embedded in static HTML
- Each island is an isolated, independently hydrating component
- The rest of the page remains static HTML with zero JavaScript by default
- Islands enable "partial hydration" - only interactive components load JavaScript

**Key Benefits:**
- **Minimal JavaScript**: Send only what's needed for interactivity
- **Improved Performance**: Faster initial page loads and better Core Web Vitals
- **Framework Agnostic**: Use React, Vue, Svelte, or any framework together
- **SEO Friendly**: Static HTML is immediately crawlable by search engines

**When to use Islands:**
- Interactive widgets (dropdown menus, modals, carousels)
- Form components with validation
- Dynamic content updates
- Any component requiring user interaction

---

### 2. Client Directives - Hydration Strategies

Astro provides fine-grained control over when and how components hydrate:

#### `client:load`
- **When**: Immediately on page load
- **Use for**: Critical interactive elements (navigation, forms)
- **Performance Impact**: Blocks rendering until JavaScript loads

```astro
<!-- Component hydrates immediately when page loads -->
<NavigationMenu client:load />
```

#### `client:visible`
- **When**: Component enters viewport
- **Use for**: Below-the-fold content, image carousels, comments
- **Performance Impact**: Best for non-critical content
- **Supports**: `rootMargin` option for pre-loading

```astro
<!-- Component hydrates when scrolled into view -->
<ImageCarousel client:visible />

<!-- Pre-load 200px before entering viewport -->
<Comments client:visible={{rootMargin: "200px"}} />
```

#### `client:idle`
- **When**: Browser is idle (after initial page load)
- **Use for**: Non-critical widgets, analytics, chat widgets
- **Performance Impact**: Defers JavaScript until browser has free time
- **Supports**: `timeout` option for maximum wait time

```astro
<!-- Component hydrates when browser is idle -->
<ChatWidget client:idle />

<!-- Hydrate after 500ms maximum wait -->
<Analytics client:idle={{timeout: 500}} />
```

#### `client:media`
- **When**: Media query matches
- **Use for**: Responsive components, mobile-only features
- **Performance Impact**: Only loads JavaScript on matching devices

```astro
<!-- Only hydrate on mobile screens -->
<MobileMenu client:media="(max-width: 768px)" />

<!-- Only hydrate on desktop -->
<DesktopSidebar client:media="(min-width: 1024px)" />
```

#### `client:only`
- **When**: Only in browser, never on server
- **Use for**: Components requiring browser APIs (window, localStorage)
- **Performance Impact**: No server-side rendering overhead

```astro
<!-- Never render on server, only in browser -->
<BrowserOnlyComponent client:only="react" />
```

---

### 3. View Transitions for Smooth Navigation

**What are View Transitions?**
- Smooth, animated transitions between pages
- Maintains state across navigation
- Better user experience compared to full page reloads

**Implementation:**

```astro
---
// In your layout file
import { ClientRouter } from 'astro:transitions';
---
<html>
  <head>
    <ClientRouter />
  </head>
  <body>
    <slot />
  </body>
</html>
```

**Transition Directives:**

```astro
<!-- Fade animation on title -->
<title transition:animate="fade">My Page</title>

<!-- Persist video state across navigation -->
<video 
  controls 
  muted 
  autoplay 
  transition:persist
  transition:name="video-player"
>
  <source src="/video.mp4" type="video/mp4" />
</video>

<!-- Custom transition duration -->
---
import { fade } from 'astro:transitions';
---
<header transition:animate={fade({ duration: '0.4s' })}>
  Navigation
</header>
```

**Lifecycle Events:**
- `astro:page-load`: New page loaded (use instead of DOMContentLoaded)
- `astro:before-preparation`: Before navigation starts
- `astro:before-swap`: Before content swap
- `astro:after-swap`: After content swap, before transition ends

---

### 4. Server Islands for On-Demand Rendering

**What are Server Islands?**
- Components that render on-demand on the server
- Enable parallel loading of dynamic content
- Improve perceived performance with progressive enhancement

```astro
---
import Avatar from '../components/Avatar.astro';
import GenericAvatar from '../components/GenericAvatar.astro';
---

<!-- Defer rendering to improve initial load -->
<Avatar server:defer>
  <!-- Fallback content while loading -->
  <GenericAvatar slot="fallback" />
</Avatar>
```

---

### 5. Code Splitting & Bundle Optimization

**Astro's Default Optimizations:**
- Automatic code splitting per page
- Zero JavaScript by default
- Only island components bundle JavaScript
- CSS is automatically scoped and optimized

**Manual Optimization:**
- Use client directives strategically
- Prefer `client:visible` or `client:idle` over `client:load`
- Split large components into smaller islands
- Use native HTML/CSS when possible

---

## Practice Part (35 min)

### Exercise 1: Optimize a Blog with Islands (20 min)

**Scenario**: You have a blog with multiple interactive components that are slowing down the page.

**Starting Code:**
```astro
---
// src/pages/blog/[slug].astro
import Layout from '../../layouts/Layout.astro';
import Header from '../../components/Header.jsx';
import TableOfContents from '../../components/TableOfContents.jsx';
import LikeButton from '../../components/LikeButton.jsx';
import Comments from '../../components/Comments.jsx';
import Newsletter from '../../components/Newsletter.jsx';
import RelatedPosts from '../../components/RelatedPosts.jsx';

const { slug } = Astro.params;
const post = await getPost(slug);
---

<Layout title={post.title}>
  <Header />
  
  <article>
    <h1>{post.title}</h1>
    
    <TableOfContents headings={post.headings} />
    
    <div set:html={post.content} />
    
    <LikeButton postId={post.id} />
  </article>
  
  <Comments postId={post.id} />
  
  <Newsletter />
  
  <RelatedPosts posts={post.related} />
</Layout>
```

**Your Tasks:**

1. **Identify which components need JavaScript**
   - Which components are truly interactive?
   - Which could be static HTML?

2. **Apply appropriate client directives**
   - `Header`: Navigation needs immediate interactivity
   - `TableOfContents`: Scroll-spy functionality, but below fold
   - `LikeButton`: Important but can wait
   - `Comments`: Below fold, not critical
   - `Newsletter`: Non-critical, can defer
   - `RelatedPosts`: Could be static

3. **Implement View Transitions**
   - Add smooth page transitions
   - Persist header state across pages

**Optimized Solution:**

```astro
---
// src/pages/blog/[slug].astro
import Layout from '../../layouts/Layout.astro';
import Header from '../../components/Header.jsx';
import TableOfContents from '../../components/TableOfContents.jsx';
import LikeButton from '../../components/LikeButton.jsx';
import Comments from '../../components/Comments.jsx';
import Newsletter from '../../components/Newsletter.jsx';
import RelatedPosts from '../../components/RelatedPosts.astro'; // üìù Changed to .astro for static rendering

const { slug } = Astro.params;
const post = await getPost(slug);
---

<Layout title={post.title}>
  <!-- 
    üìù client:load - Navigation needs immediate interactivity
    üìù transition:persist - Maintains header state across pages
  -->
  <Header 
    client:load 
    transition:persist 
    transition:name="main-header" 
  />
  
  <article>
    <h1 transition:animate="fade">{post.title}</h1>
    
    <!-- 
      üìù client:visible - Only hydrates when scrolled into view
      üìù Pre-loads 100px before entering viewport
    -->
    <TableOfContents 
      headings={post.headings} 
      client:visible={{rootMargin: "100px"}}
    />
    
    <div set:html={post.content} />
    
    <!-- 
      üìù client:idle - Defers until browser is idle
      üìù Interactive but not critical for initial render
    -->
    <LikeButton 
      postId={post.id} 
      client:idle 
    />
  </article>
  
  <!-- 
    üìù client:visible - Comments are below fold
    üìù No need to load until user scrolls down
  -->
  <Comments 
    postId={post.id} 
    client:visible 
  />
  
  <!-- 
    üìù client:idle with timeout - Newsletter can wait
    üìù Maximum 1 second wait ensures it loads eventually
  -->
  <Newsletter 
    client:idle={{timeout: 1000}} 
  />
  
  <!-- 
    üìù No client directive - Renders as static HTML
    üìù Related posts don't need interactivity
  -->
  <RelatedPosts posts={post.related} />
</Layout>
```

**Layout with View Transitions:**

```astro
---
// src/layouts/Layout.astro
import { ClientRouter } from 'astro:transitions';

interface Props {
  title: string;
}

const { title } = Astro.props;
---

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width" />
    <title transition:animate="fade">{title}</title>
    
    <!-- üìù Enables View Transitions site-wide -->
    <ClientRouter />
  </head>
  <body>
    <slot />
    
    <!-- üìù Script runs after every page navigation -->
    <script>
      document.addEventListener('astro:page-load', () => {
        // üìù Re-initialize any page-specific functionality
        console.log('Page loaded:', window.location.pathname);
        
        // üìù Example: Setup mobile menu toggle
        const mobileMenuButton = document.querySelector('.mobile-menu-toggle');
        if (mobileMenuButton) {
          mobileMenuButton.addEventListener('click', () => {
            document.querySelector('.nav-links')?.classList.toggle('expanded');
          });
        }
      });
    </script>
  </body>
</html>
```

**Expected Performance Improvements:**
- ‚ö° **Initial Load**: 60-80% reduction in JavaScript
- üéØ **Time to Interactive**: 2-3x faster
- üì¶ **Bundle Size**: Reduced from ~150KB to ~20KB
- üé® **Smooth Navigation**: No page flickers

---

### Exercise 2: Implement Progressive Enhancement (15 min)

**Scenario**: Create a product filter that works without JavaScript but enhances with it.

**Task**: Build a search/filter component that:
- Works as a form submission (no JS)
- Enhances with client-side filtering when JS loads
- Uses appropriate hydration strategy

**Solution:**

```astro
---
// src/components/ProductFilter.astro
export interface Props {
  products: Product[];
  initialSearch?: string;
}

const { products, initialSearch = '' } = Astro.props;

// üìù Filter server-side based on URL params
const url = new URL(Astro.request.url);
const searchQuery = url.searchParams.get('search') || initialSearch;
const filteredProducts = products.filter(p => 
  p.name.toLowerCase().includes(searchQuery.toLowerCase())
);
---

<div class="product-filter">
  <!-- üìù Form works without JavaScript (progressive enhancement) -->
  <form method="get" action={Astro.url.pathname}>
    <input 
      type="search" 
      name="search" 
      placeholder="Search products..."
      value={searchQuery}
    />
    <button type="submit">Search</button>
  </form>

  <!-- üìù Server-rendered results -->
  <div class="product-grid">
    {filteredProducts.map(product => (
      <article class="product-card">
        <img src={product.image} alt={product.name} loading="lazy" />
        <h3>{product.name}</h3>
        <p>${product.price}</p>
      </article>
    ))}
  </div>
</div>

<!-- üìù Enhanced client-side filtering with client:idle -->
<script>
  // üìù Only runs when browser is idle
  document.addEventListener('astro:page-load', () => {
    const form = document.querySelector('.product-filter form');
    const input = form?.querySelector('input[name="search"]');
    const grid = document.querySelector('.product-grid');
    
    if (!form || !input || !grid) return;
    
    // üìù Store all products for client-side filtering
    const allProducts = Array.from(grid.children);
    
    // üìù Prevent form submission, filter client-side instead
    form.addEventListener('submit', (e) => {
      e.preventDefault();
    });
    
    // üìù Real-time filtering as user types
    input.addEventListener('input', (e) => {
      const query = (e.target as HTMLInputElement).value.toLowerCase();
      
      allProducts.forEach((product) => {
        const text = product.textContent?.toLowerCase() || '';
        const matches = text.includes(query);
        
        // üìù Show/hide products based on search
        (product as HTMLElement).style.display = matches ? '' : 'none';
      });
    });
  });
</script>

<style>
  .product-filter {
    /* üìù Styles */
  }
  
  .product-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
    gap: 2rem;
  }
  
  .product-card {
    /* üìù Card styles */
  }
</style>
```

**Alternative with React Component:**

```astro
---
// src/pages/products.astro
import Layout from '../layouts/Layout.astro';
import ProductFilter from '../components/ProductFilter.jsx';
import { getProducts } from '../lib/products';

const products = await getProducts();
---

<Layout title="Products">
  <h1>Our Products</h1>
  
  <!-- 
    üìù client:idle - Non-critical interactive component
    üìù Will enhance the experience but page works without it
  -->
  <ProductFilter 
    products={products} 
    client:idle 
  />
</Layout>
```

```jsx
// src/components/ProductFilter.jsx
import { useState, useMemo } from 'react';

export default function ProductFilter({ products }) {
  const [search, setSearch] = useState('');
  
  // üìù Memoize filtered results for performance
  const filteredProducts = useMemo(() => {
    if (!search) return products;
    
    return products.filter(product =>
      product.name.toLowerCase().includes(search.toLowerCase())
    );
  }, [products, search]);

  return (
    <div className="product-filter">
      <input
        type="search"
        placeholder="Search products..."
        value={search}
        onChange={(e) => setSearch(e.target.value)}
        aria-label="Search products"
      />
      
      <div className="product-grid">
        {filteredProducts.map(product => (
          <article key={product.id} className="product-card">
            <img src={product.image} alt={product.name} loading="lazy" />
            <h3>{product.name}</h3>
            <p>${product.price}</p>
          </article>
        ))}
      </div>
      
      {filteredProducts.length === 0 && (
        <p>No products found matching "{search}"</p>
      )}
    </div>
  );
}
```

---

## Quick Review - Key Concepts (5 min)

### 1. Islands Architecture
- **Zero JavaScript by default** - Astro sends only HTML and CSS
- **Partial hydration** - Only interactive components load JavaScript
- **Framework agnostic** - Mix React, Vue, Svelte in the same page

### 2. Hydration Strategy Decision Tree
```
Is the component interactive? 
  NO  ‚Üí Use .astro component (no client directive)
  YES ‚Üí Continue...

Is it critical for initial render?
  YES ‚Üí Use client:load
  NO  ‚Üí Continue...

Is it visible in viewport on load?
  YES ‚Üí Use client:idle
  NO  ‚Üí Use client:visible

Special cases:
  - Responsive components ‚Üí client:media
  - Browser-only code ‚Üí client:only
```

### 3. View Transitions Best Practices
- ‚úÖ Add `<ClientRouter />` in layout head
- ‚úÖ Use `transition:persist` for stateful components
- ‚úÖ Use `transition:name` for matching elements
- ‚úÖ Listen to `astro:page-load` instead of `DOMContentLoaded`
- ‚úÖ Use `data-astro-reload` to opt-out specific links

### 4. Performance Optimization Checklist
- ‚úÖ **Measure first** - Use Lighthouse, WebPageTest
- ‚úÖ **Prefer static** - Use .astro components when possible
- ‚úÖ **Lazy load** - Use `client:visible` for below-fold content
- ‚úÖ **Defer non-critical** - Use `client:idle` for widgets
- ‚úÖ **Split strategically** - Keep islands small and focused

---

## Checklist - What You Should Know After Day 5

- ‚úÖ Understand Astro's Islands Architecture and its benefits
- ‚úÖ Choose the right client directive for each component
- ‚úÖ Implement View Transitions for smooth navigation
- ‚úÖ Persist component state across page navigations
- ‚úÖ Use progressive enhancement patterns
- ‚úÖ Optimize bundle size by minimizing JavaScript
- ‚úÖ Leverage Server Islands for on-demand rendering
- ‚úÖ Debug and profile Astro applications

---

## Quick Reference Card - Save This!

### Client Directives Cheat Sheet

```astro
<!-- No directive = Static HTML only -->
<StaticComponent />

<!-- Load immediately on page load -->
<CriticalComponent client:load />

<!-- Load when scrolled into view -->
<BelowFoldComponent client:visible />
<BelowFoldComponent client:visible={{rootMargin: "200px"}} />

<!-- Load when browser is idle -->
<NonCriticalComponent client:idle />
<NonCriticalComponent client:idle={{timeout: 500}} />

<!-- Load only on specific screen sizes -->
<MobileMenu client:media="(max-width: 768px)" />

<!-- Only render in browser, never on server -->
<BrowserOnlyComponent client:only="react" />
```

### View Transitions

```astro
---
import { ClientRouter, fade, slide } from 'astro:transitions';
---

<!-- In layout head -->
<ClientRouter />

<!-- Animated title -->
<title transition:animate="fade">Page Title</title>

<!-- Custom animation duration -->
<header transition:animate={fade({ duration: '0.4s' })}>

<!-- Persist element across navigation -->
<video transition:persist transition:name="video-player">

<!-- Named transition for matching elements -->
<aside transition:name="sidebar">
```

### Lifecycle Events

```astro
<script>
  // Runs after every page load/navigation
  document.addEventListener('astro:page-load', () => {
    console.log('Page loaded');
    // Initialize components here
  });

  // Before navigation starts
  document.addEventListener('astro:before-preparation', (e) => {
    console.log('Starting navigation');
  });

  // Before content swap
  document.addEventListener('astro:before-swap', (e) => {
    console.log('About to swap content');
  });

  // After content swap
  document.addEventListener('astro:after-swap', (e) => {
    console.log('Content swapped');
  });
</script>
```

### Server Islands

```astro
---
import DynamicComponent from '../components/Dynamic.astro';
import Fallback from '../components/Fallback.astro';
---

<!-- Defer rendering to improve perceived performance -->
<DynamicComponent server:defer>
  <Fallback slot="fallback" />
</DynamicComponent>
```

### Performance Patterns

```astro
---
// ‚úÖ Good: Static by default
import Header from '../components/Header.astro';
import Footer from '../components/Footer.astro';

// ‚úÖ Good: Interactive only when needed
import SearchBox from '../components/SearchBox.jsx';
import Comments from '../components/Comments.jsx';
---

<Header /> <!-- Static HTML -->

<main>
  <!-- Search at top = client:load -->
  <SearchBox client:load />
  
  <!-- Content is static -->
  <article>...</article>
  
  <!-- Comments below fold = client:visible -->
  <Comments client:visible />
</main>

<Footer /> <!-- Static HTML -->
```

---

## What's Next?

Tomorrow we'll cover:
- **Forms and Validation** - Handling form submissions in Astro
- **API Routes** - Creating server endpoints
- **Actions API** - Progressive enhancement for forms
- **Database Integration** - Working with databases in Astro
- **Authentication** - User authentication patterns

---

## Additional Resources

- üìö [Astro Islands Documentation](https://docs.astro.build/en/concepts/islands/)
- üé¨ [Astro View Transitions Guide](https://docs.astro.build/en/guides/view-transitions/)
- ‚ö° [Performance Best Practices](https://docs.astro.build/en/concepts/why-astro/#server-first)
- üõ†Ô∏è [Client Directives Reference](https://docs.astro.build/en/reference/directives-reference/)

---

## Practice Project Ideas

1. **Blog with Optimized Comments**: Build a blog where comments load only when visible
2. **E-commerce Product Page**: Product images lazy load, cart is immediately interactive
3. **Dashboard**: Critical metrics load first, detailed charts load when idle
4. **Documentation Site**: Table of contents hydrates on scroll, search loads immediately

---

**Remember**: The best JavaScript is no JavaScript. Use Astro's islands to send only what's necessary, exactly when it's needed.
